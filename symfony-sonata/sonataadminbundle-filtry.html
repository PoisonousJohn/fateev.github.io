<p>Лично для меня - фильтры один из самых краеугольных камней, ибо это любимое требование заказчика, и очень часто у этого заказчика очень нестандартные запросы к фильтрам.</p>

<p>Итак, соната предоставляет несколько возможностей для внедрения фильтрации данных.</p>

<ol>
  <li>Неявные фильтры. Могут понадобится в случае, когда данные нужно фильтровать для пользователя определенным образом, но сам пользователь об этом знать не должен. Как пример: пользователь должен видеть только свои посты.</li>
</ol>

<p>Стандартное поведение админ классов можно легко модифицировать с помощью AdminExtension’ов. <strong>AdminExtension</strong> - это сервис, который админ класс запускает после того как сделает свою основную работу по конфигурации. AdminExtension’ов может быть несколько. Они включают в себя основные методы админ класса, такие как configureFormFields, configureDatagridFilters и др. Мы рассмотрим метод configureQuery, с помощью которого можно изменить стандартный запрос, который выполняется, когда мы просматриваем список сущностей. В моем случае я буду выводить только те сущности, в которых поле parent  является пустым, об иных сущностях пользователю знать не стоит</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"> <span class="cp">&lt;?php</span>
<span class="k">namespace</span> <span class="nx">Mtools\RatecardBundle\Admin</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Sonata\AdminBundle\Admin\AdminExtension</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Sonata\AdminBundle\Admin\AdminInterface</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Sonata\AdminBundle\Datagrid\ProxyQueryInterface</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">RatecardAdminExtension</span> <span class="k">extends</span> <span class="nx">AdminExtension</span>
<span class="p">{</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">configureQuery</span><span class="p">(</span><span class="nx">AdminInterface</span> <span class="nv">$admin</span><span class="p">,</span> <span class="nx">ProxyQueryInterface</span> <span class="nv">$query</span><span class="p">,</span> <span class="nv">$context</span> <span class="o">=</span> <span class="s1">'list'</span><span class="p">)</span>
    <span class="p">{</span>

            <span class="nv">$query</span><span class="o">-&gt;</span><span class="na">getQueryBuilder</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">where</span><span class="p">(</span><span class="s1">'o.parent IS NULL'</span><span class="p">);</span>

    <span class="p">}</span>

<span class="p">}</span></code></pre></figure>

<p>Конечно, наш класс унаследован от AdminExtension</p>

<p>Определение сервиса следующее:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">mtools.ratecard.admin.extension:</span><span class="err">
</span>
        <span class="s">id</span><span class="pi">:</span> <span class="s">mtools.ratecard.admin.extension</span><span class="err">
</span>
        <span class="s">class</span><span class="pi">:</span> <span class="s">Mtools\RatecardBundle\Admin\RatecardAdminExtension</span><span class="err">
</span>
        <span class="s">tags:</span><span class="err">
</span>
            <span class="s">- { name</span><span class="pi">:</span> <span class="s">sonata.admin.extension, target</span><span class="pi">:</span> <span class="s">mtools.ratecard.admin }</span><span class="err">
</span>
 </code></pre></figure>

<p>target в секции tag - это id сервиса админ класса, к которому будет присоединен AdminExtension</p>
<blockquote>С помощью AdminExtension'ов очень удобно джойнить нужные сущности, чтобы потом фильтровать по этим полям внутри админ класса (это второй способ, рассмотрен ниже)</blockquote>
<ol>
  <li>Часто возникает необходимость реализовать нестандартную логику фильтрации по определнному полю, а времени, чтобы оформлять данный фильтр как отдельный сервис нет, да и такой фильтр может встреаться только в одном месте. Для таких случаев SonataAdminBundle предоставляет тип фильтра <strong>doctrine_orm_callback</strong>. Здесь все просто как 2 копейки:</li>
</ol>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="o">...</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">configureDatagridFilters</span><span class="p">(</span><span class="nx">DatagridMapper</span> <span class="nv">$datagridMapper</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$datagridMapper</span>
        <span class="o">-&gt;</span><span class="na">add</span><span class="p">(</span><span class="s1">'codes'</span><span class="p">,</span> <span class="s1">'doctrine_orm_callback'</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">'label'</span>         <span class="o">=&gt;</span> <span class="s1">'Код'</span><span class="p">,</span>
            <span class="s1">'callback'</span>      <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="nv">$this</span><span class="p">,</span> <span class="s1">'getCodesFilter'</span><span class="p">),</span>
            <span class="s1">'field_type'</span>    <span class="o">=&gt;</span> <span class="s1">'genemu_jquerychosen'</span><span class="p">,</span>
            <span class="s1">'field_options'</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
                <span class="s1">'class'</span>     <span class="o">=&gt;</span> <span class="s1">'Mtools\ClientBundle\Entity\Client'</span><span class="p">,</span>
                <span class="s1">'widget'</span>    <span class="o">=&gt;</span> <span class="s1">'entity'</span><span class="p">,</span>
                <span class="s1">'multiple'</span>  <span class="o">=&gt;</span> <span class="kc">false</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">getCodesFilter</span><span class="p">(</span><span class="nv">$queryBuilder</span><span class="p">,</span> <span class="nv">$alias</span><span class="p">,</span> <span class="nv">$field</span><span class="p">,</span> <span class="nv">$value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="kc">null</span> <span class="o">===</span> <span class="nv">$value</span><span class="p">[</span><span class="s1">'value'</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nv">$queryBuilder</span><span class="o">-&gt;</span><span class="na">leftJoin</span><span class="p">(</span><span class="nb">sprintf</span><span class="p">(</span><span class="s1">'%s.codes'</span><span class="p">,</span> <span class="nv">$alias</span><span class="p">),</span> <span class="s1">'c'</span><span class="p">);</span>
    <span class="nv">$queryBuilder</span><span class="o">-&gt;</span><span class="na">andWhere</span><span class="p">(</span><span class="s1">'c.code = :code'</span><span class="p">);</span>
    <span class="nv">$queryBuilder</span><span class="o">-&gt;</span><span class="na">setParameter</span><span class="p">(</span><span class="s1">'code'</span><span class="p">,</span> <span class="nv">$value</span><span class="p">[</span><span class="s1">'value'</span><span class="p">]);</span>
<span class="p">}</span>
<span class="o">...</span></code></pre></figure>

<p>Сам фильтр мы так же, как и обычные, описываем в методе configureDatagridFilters, с той разницей, что тип фильтра указываем doctrine_orm_callback, а в опциях фильтра обязательно указываем callback - метод, который будет вызываться для формирования QueryBuilder’a соответственно нашему фильтру. Иначе говоря, в этот метод передается сам QueryBuilder, $alias - основной алиас сущности, $field - какое то мистическая переменная, я не нашел ей применения, и $value - собственно значение из фильтра, которое ввел пользователь.</p>

<p>Внутри функции callback’a в данном случае добавляется джоин (что, как я и говорил раньше, можно вынести в AdminExtension, и даже нужно, если этих джоинов множество), ну, и само условие для фильтрации.</p>

<p>Еще любопытные опции, на поиск которых я потратил некоторое время:</p>
<ul>
	<li>field_type - тип поля, которое будет отображаться для ввода пользователем значения</li>
	<li>field_options - опции этого поля, которые обычно идут третьим аргументом в FormMapper'e метода configureFormFields</li>
</ul>
<div>В итоге, мы получаем миловидный (благодаря GenemuFormBundle) фильтр с произвольной логикой</div>
<div>Так выглядят фильтры на одном из проектов:</div>
<div><a href="http://fateev.pro/wp-content/uploads/2012/10/Screen-Shot-2012-10-09-at-1.32.37-AM.png"><img title="Screen Shot 2012-10-09 at 1.32.37 AM" src="http://fateev.pro/wp-content/uploads/2012/10/Screen-Shot-2012-10-09-at-1.32.37-AM.png" alt="" width="910" height="238" /></a></div>
<div>&nbsp;</div>
<div>3. Есть и третий способ - вынести фильтр в полностью самостоятельный сервис. Актуально, когда этот фильтр часто встречается в вашем проекте. Рассмотрю этот способ в отдельной статье.</div>
<div>&nbsp;</div>
<h3>Значение фильтров по-умолчанию</h3>
<p>Однажды столкнулся с задачей, что необходимо было явно указать в фильтрах значение по-умолчанию, как если бы пользователь сам его выбрал.</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
    <span class="o">...</span>
    <span class="k">public</span> <span class="k">function</span>  <span class="nf">getFilterParameters</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$parameters</span> <span class="o">=</span> <span class="k">parent</span><span class="o">::</span><span class="na">getFilterParameters</span><span class="p">();</span>

        <span class="nv">$filterUsers</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$parameters</span><span class="p">[</span><span class="s1">'managers'</span><span class="p">][</span><span class="s1">'value'</span><span class="p">])</span> <span class="o">||</span> <span class="o">!</span><span class="nb">sizeof</span><span class="p">(</span><span class="nv">$parameters</span><span class="p">[</span><span class="s1">'managers'</span><span class="p">][</span><span class="s1">'value'</span><span class="p">]))</span> <span class="p">{</span>

            <span class="nv">$parameters</span><span class="p">[</span><span class="s1">'managers'</span><span class="p">][</span><span class="s1">'value'</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$filterUsers</span><span class="p">;</span>
            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">datagridValues</span><span class="p">[</span><span class="s1">'managers'</span><span class="p">][</span><span class="s1">'value'</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$filterUsers</span><span class="p">;</span>
        <span class="p">}</span>


        <span class="k">return</span> <span class="nv">$parameters</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>Ключ ко всему - метод getFilterParameters, который соната вызывает, чтобы составить список сущностей для listAction. Данный метод заполняет свойство datagridValues соответствующими значениями. В данном случае предполагается, что $filterUsers - это массив с id’шками пользователей.</p>
