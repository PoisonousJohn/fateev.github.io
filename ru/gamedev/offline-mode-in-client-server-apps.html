<!DOCTYPE html>
<html lang="en">

  
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>
        
        Оффлайн режим в клиент-серверных приложениях &middot; Ivan Fateev&#039;s Blog
        
    </title>

    <meta property="og:type" content="website" />
    <meta property="og:title" content="Оффлайн режим в клиент-серверных приложениях" />
    <meta property="og:description" content="Оффлайн режим в клиент-серверных приложениях" />

    <!-- CSS -->
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="/wp-content/uploads/2012/09/favicon.png">

    <style>


        .post-title {
            font-size: 2rem;
        }

        nav {
            margin-bottom: 1rem;
        }

        footer {
            clear: both;
        }

        .skills {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-gap: 10px;
            margin-right: 1rem;
        }

        section.about {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-gap: 10px;
        }

        .about-pic {
            min-width: 300px;
            width: 20%;
            text-align: center;
            margin-right: 1rem;
            grid-column: 2;

        }

        .social-links {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
        }

        .social-links img {
            width: 50px;
        }

        .about-details {
            grid-column: span 3;
        }

        @media (min-width: 600px) {
            .skills {
                margin-right: 0px;
            }
            .about-details {
                grid-column: 1 none;
            }
        }


        .skill-value {
            margin-top: 0.2rem;
            border: solid 1px #ccc;
            height: 0.7rem;
            max-width: 300px;
            width: 100%;
        }
        .skill-value div {
            background-color: #aaa;
            height: 100%;
        }


        .catalogue-item {
            border: none;
            padding: 0px;
        }

        div.tags, div.tags a {
            /* display: none; */
            border: 0px;
            padding: 0px;
            color: #aaa;
        }

        div.tags a {
            text-decoration: underline;
        }

        div.tags {
            border-bottom: 1px solid #e5e5e5;
            padding-bottom: 2rem;
            margin-bottom: 2rem;
        }

        .post img {
            /* float: left; */
            padding-bottom: 1rem;
        }

        .catalogue-item img {
            /* width: 100px; */
            margin-right: 1rem;
            max-width: 400px;
        }

        div.pagination {
            clear: both;
        }

        html {
            font-family: 'Times New Roman', Roman, serif;
            font-size: large;
            /* letter-spacing: 1px; */
            /* font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif */
        }

    </style>
</head>

  <body>
    <nav class="nav">
      <div class="nav-container">
        <a href="/">
          <h2 class="nav-title">Ivan Fateev&#039;s Blog</h2>
        </a>
        <ul>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </nav>

    <main>
        <section id="content">
            <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        Poisonous John
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2018-07-11 17:33:30 +0300">July 11, 2018</time>
    
  </div>

  <h1 class="post-title">Оффлайн режим в клиент-серверных приложениях</h1>
  <div class="post-line"></div>

  <p>Игры, да и приложения в целом, часто подразумевают наличие механик, завязанных на сервер. Сейчас не часто встретишь оффлайн игру. Как минимум, игры имеют различные социальные составляющие: кланы, чаты, список друзей, да что угодно. И каждый пук уходит в аналитику.</p>

<p>Конечно же, сетап команды предполагает два отдельных юнита, которые занимаются своей частью: одни – сервером, другие – клиентом. Есть несколько вариантов, как ведется разработка.</p>

<h2 id="параллельная-разработка-по-контракту">Параллельная разработка по контракту</h2>

<p>На этапе планирования задачи, команды договариваются о некоем контракте. Клиентские разработчики говорят что им необходимо. Серверные разработчики прикидывают как это сделать. В конечном счете договариваются о неком API. И каждый уходит пилить свою часть.</p>

<p>Плюсы:</p>

<ul>
  <li>Ускорение за счет параллельной разработки</li>
  <li>Работа ведется относительно независимо, сходясь только в точке контракта</li>
</ul>

<p>Минусы:</p>

<ul>
  <li>Требует опытной комманды</li>
  <li>Требует налаженной коммуникации между юнитами</li>
</ul>

<p>Немного подробнее про минусы. Если команда не очень опытная, или в коммуникация между юнитами не настроена как следует, то после завершения работы над фичой одной из команд, обычно необходима еще несколько итераций, так как невозможно t</p>

<h2 id="ведущийведомый">Ведущий/ведомый</h2>

<p>Один из юнитов в разработки может быть ведущим, и работать на опережение. Этот юнит должен быть на острие бизнес-требований. Обычно это фронтэнд часть, но зависит от продукта.</p>

<p>Итак, если лидирует фронтэнд, то как только этот юнит закончил свою часть, то у них должно быть четкое понимание того, что им нужно от бэкэнда. То есть они могут предоставить детальные требования для серверной команды.</p>

<p>Плюсы:</p>

<ul>
  <li>Меньше издержек из-за меняющихся требований</li>
  <li>Более быстрые итерации, так как все “пилоты” делаются одним юнитом</li>
  <li>При переходе к следующему этапу разработки, на руках есть почти финальные требования и воркфлоу</li>
</ul>

<p>Минусы:</p>

<ul>
  <li>Разработка ведется последовательно</li>
  <li>Нужно подготовить разработку таким образом, чтобы разработка могла вестись независимо от другого юнита</li>
</ul>

<p>По моему опыту данный подход работает лучше. Например, разрабатывая фичу для игры, еще даже не известно пойдет ли фича в релиз, или ее выкинут на этапе прототипа.</p>

<p>Поэтому разрабатывать функционал на сервере, до того как фичу опробовали на клиенте, может быть пустой тратой времени.</p>

<p>Встает вопрос: как же разрабатывать фичу, которая завязана на сервер, но без сервера?</p>

<p>Ответ прост: сделать оффлайн режим с помощью заглушек.</p>

<h2 id="оффлайн-режим">Оффлайн режим</h2>

<p>Что я понимаю под оффлайн режимом? Я не имею ввиду, что игра должна поддерживать оффлайн геймплей. Если это не заложено в дизайн изначально, то переводить все на поддержку оффлайна – безумство.</p>

<p>Под оффлайн режимом я имею ввиду специальный билд (или настройку для игры), которая позволяет разработчику полностью выключить любые зависимости от внешних сервисов.</p>

<p>Это можно сделать кучей способов. Я расскажу про тот, который использовал я.</p>

<p>Я уже расскзывал про то как избавиться от лишних зависимостей в коде <a href="https://medium.com/@poisonousjohn/%D0%B0%D0%BD%D1%82%D0%B8%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%B2-%D0%B8%D0%B3%D1%80%D0%BE%D0%B2%D0%BE%D0%B9-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B5-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D0%B2-%D0%BA%D0%BE%D0%B4%D0%B5-1bd879ef46ad">в этой статье</a>.</p>

<p>Если вы уже используете Dependency Injection, или ваши зависимости представлены в виде интерфейсов, то тут все совсем просто.</p>

<p>Все взаимодействие с сервером вы пускаете через Фасад (Facade). При билде делается настройка “isOffline”, и если она включена, подставляются заглушки для всех сетевых сервисов.</p>

<p><a href="/imgs/offline-mode-facade.png"><img src="/imgs/offline-mode-facade.png" alt="Offline mode class diagram" /></a></p>

<p>На диаграмме я показал, что API может быть разделен на разные компоненты, при этом фасад их скрывает. Каждый из компонентов имеет оффлайн заглушку.</p>

<p>Для заглушек есть несколько вариантов поведения:</p>

<ol>
  <li>Возвращать один и тот же ответ</li>
  <li>Реализовывать простую бизнес логику</li>
</ol>

<p>Первый вариант совсем бесполезный. Он не поможет погонять какую-либо фичу в оффлайне. Второй же вариант вполне годный. Но хранить стейт, пока не убьешь приложение – тоже не очень полезно. Поэтому отдельно я вынес заглушку для сериализации стейта, которую могут использовать стабы.</p>

<p>Такой подход позволить написать и детально потестить бизнес логику без всякого участия серверных разработчиков и привязки к какой-либо инфраструктуре. Плюс ко всему, вы можете писать код где угодно, даже без доступа к интернету (в самолете?).</p>

<p>Когда код будет завершен с клиентской стороны, серверные разработчики могут смотреть в оффлайн имплементацию и иметь представление о том, что приложение ожидает от серверного API и конкретно как его использует.</p>

<p>Конечно у оффлайн режима есть и свои минусы:</p>

<ul>
  <li>Нужно поддерживать две реализации: онлайн и оффлайн</li>
  <li>Легаси приложениям может быть сложно переехать на оффлайн режим</li>
  <li>Если бизнес логика сложна, а на клиенте ее присутствие в продакшене не планируется, то может быть очень накладно делать ее на клиенте, тут уж надо искать обходные пути</li>
</ul>

<h2 id="гибридный-режим">Гибридный режим</h2>

<p>Есть еще один вариант, когда полный оффлайн режим реализовывать очень проблемно. Это гибридный режим. Под таким режимом я понимаю, что все API работает как обычно, а при реализации новой фичи, часть, завязанная на сервер стаббится. Как только с реализацией фичи на клиенте закончено, стаб убирается и тестится с сервером. Наличие юнит и интеграционных тестов позволяет довольно быстро все проверить.</p>

<p>Такой вариант не очень гибкий. Наверняка им многие пользуются. Тем не менее, некоторые делают стабы прямо с серверной стороны, что тоже требует лишних телодвижений, передеплоев и т.д.</p>

<h2 id="подводим-итоги">Подводим итоги</h2>

<p>Скорость итераций при работе над фичами невероятно важна. Я описал тот вариант работы, который эффективен для нашей команды. Оффлайн режим позволил убрать лишние итерации при изменении контракта, а так же избавить от лишней серверной разработки, когда фичи зарезаются.</p>

<p>У оффлайн режима есть много всяких побочных плюшек, таких как локальное сохранение прогресса на устройстве. Конечно же у такого подхода есть и недостатки.</p>

<p>Надеюсь статья натолкнула вас на интересные мысли :). Пишите, всегда рад поболтать и услышать про другие решения, которые работают для вас.</p>


</div>

<div class="pagination">
  
  
    <a href="/chronicles/poisonous_johns_lair_telegram_channel.html" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>

        </section>
    </main>

    <footer>
      <span>
        &copy; <time datetime="2018-07-13 20:07:35 +0300">2018</time> . Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
      </span>

    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-34509649-1', 'auto');
        ga('send', 'pageview');

    </script>

    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function (d, w, c) {
            (w[c] = w[c] || []).push(function() {
                try {
                    w.yaCounter16940533 = new Ya.Metrika({
                        id:16940533,
                        clickmap:true,
                        trackLinks:true,
                        accurateTrackBounce:true,
                        webvisor:true
                    });
                } catch(e) { }
            });

            var n = d.getElementsByTagName("script")[0],
                s = d.createElement("script"),
                f = function () { n.parentNode.insertBefore(s, n); };
            s.type = "text/javascript";
            s.async = true;
            s.src = "https://mc.yandex.ru/metrika/watch.js";

            if (w.opera == "[object Opera]") {
                d.addEventListener("DOMContentLoaded", f, false);
            } else { f(); }
        })(document, window, "yandex_metrika_callbacks");
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/16940533" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    </footer>
  </body>
</html>